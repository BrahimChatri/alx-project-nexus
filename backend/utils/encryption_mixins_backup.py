"""
Advanced encryption mixins and decorators for Django models
Provides automatic encryption/decryption of sensitive fields
"""

from django.db import models
from django.core.exceptions import ValidationError
from django.conf import settings
from typing import List, Dict, Any, Optional
import logging
from .encryption import encrypt_data, decrypt_data, EncryptionError, DecryptionError

logger = logging.getLogger(__name__)


class EncryptedFieldMixin:
    """Mixin to handle encrypted fields in Django models"""
    
    # Override in subclass to specify which fields should be encrypted
    ENCRYPTED_FIELDS: List[str] = []
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._original_values = {}
        self._decrypted_cache = {}
    
    def save(self, *args, **kwargs):
        """Override save to encrypt sensitive fields before saving"""
        # Encrypt fields before saving
        self._encrypt_fields()
        
        # Call parent save
        super().save(*args, **kwargs)
        
        # Update original values after save
        self._update_original_values()
    
    def refresh_from_db(self, using=None, fields=None):
        """Override refresh to clear decrypted cache"""
        super().refresh_from_db(using=using, fields=fields)
        self._decrypted_cache.clear()
        self._update_original_values()
    
    def _encrypt_fields(self):
        """Encrypt all fields marked for encryption"""
        for field_name in self.ENCRYPTED_FIELDS:
            if hasattr(self, field_name):
                current_value = getattr(self, field_name)
                
                # Only encrypt if value has changed and is not None/empty
                if (current_value and 
                    current_value != self._original_values.get(field_name) and
                    not self._is_already_encrypted(field_name, current_value)):\n                    
                    try:\n                        encrypted_value = encrypt_data(current_value)\n                        setattr(self, field_name, encrypted_value)\n                        logger.debug(f\"Encrypted field '{field_name}' for {self.__class__.__name__}\")\n                    except EncryptionError as e:\n                        logger.error(f\"Failed to encrypt field '{field_name}': {str(e)}\")\n                        raise ValidationError(f\"Failed to encrypt {field_name}: {str(e)}\")\n    \n    def _is_already_encrypted(self, field_name: str, value: str) -> bool:\n        \"\"\"Check if a field value is already encrypted\"\"\"\n        if not value:\n            return False\n        \n        # Check if value looks like encrypted data (base64 encoded)\n        try:\n            import base64\n            base64.b64decode(value.encode('ascii'))\n            # Additional check: encrypted data is typically longer\n            return len(value) > 50 and '=' in value\n        except:\n            return False\n    \n    def get_decrypted_field(self, field_name: str) -> Optional[str]:\n        \"\"\"Get decrypted value of an encrypted field\"\"\"\n        if field_name not in self.ENCRYPTED_FIELDS:\n            return getattr(self, field_name)\n        \n        # Check cache first\n        if field_name in self._decrypted_cache:\n            return self._decrypted_cache[field_name]\n        \n        encrypted_value = getattr(self, field_name)\n        if not encrypted_value:\n            return ''\n        \n        try:\n            decrypted_value = decrypt_data(encrypted_value)\n            # Cache the decrypted value\n            self._decrypted_cache[field_name] = decrypted_value\n            return decrypted_value\n        except DecryptionError as e:\n            logger.error(f\"Failed to decrypt field '{field_name}': {str(e)}\")\n            # Return original value as fallback\n            return encrypted_value\n    \n    def set_field_value(self, field_name: str, value: str):\n        \"\"\"Set field value (will be encrypted on save if field is marked for encryption)\"\"\"\n        setattr(self, field_name, value)\n        # Clear from cache since we're setting a new value\n        self._decrypted_cache.pop(field_name, None)\n    \n    def get_all_decrypted_fields(self) -> Dict[str, str]:\n        \"\"\"Get all decrypted field values as a dictionary\"\"\"\n        result = {}\n        for field_name in self.ENCRYPTED_FIELDS:\n            result[field_name] = self.get_decrypted_field(field_name)\n        return result\n    \n    def _update_original_values(self):\n        \"\"\"Update original values for change detection\"\"\"\n        for field_name in self.ENCRYPTED_FIELDS:\n            if hasattr(self, field_name):\n                self._original_values[field_name] = getattr(self, field_name)\n\n\nclass EncryptedCharField(models.CharField):\n    \"\"\"Custom CharField that automatically handles encryption/decryption\"\"\"\n    \n    def __init__(self, *args, **kwargs):\n        # Encrypted data is typically longer, so adjust max_length\n        if 'max_length' in kwargs and kwargs['max_length'] < 500:\n            kwargs['max_length'] = 500\n        super().__init__(*args, **kwargs)\n    \n    def from_db_value(self, value, expression, connection):\n        \"\"\"Decrypt value when loading from database\"\"\"\n        if value is None:\n            return value\n        try:\n            return decrypt_data(value)\n        except:\n            # Return original value if decryption fails\n            return value\n    \n    def to_python(self, value):\n        \"\"\"Convert value to Python representation\"\"\"\n        if isinstance(value, str) or value is None:\n            return value\n        return str(value)\n    \n    def get_prep_value(self, value):\n        \"\"\"Encrypt value before saving to database\"\"\"\n        if value is None or value == '':\n            return value\n        \n        try:\n            # Check if already encrypted\n            if self._is_encrypted(value):\n                return value\n            return encrypt_data(value)\n        except:\n            # Return original value if encryption fails\n            logger.error(f\"Failed to encrypt value for {self.name}\")\n            return value\n    \n    def _is_encrypted(self, value: str) -> bool:\n        \"\"\"Check if value appears to be encrypted\"\"\"\n        if not value or len(value) < 50:\n            return False\n        try:\n            import base64\n            base64.b64decode(value.encode('ascii'))\n            return '=' in value  # Base64 padding\n        except:\n            return False\n\n\ndef encrypted_property(field_name: str):\n    \"\"\"Decorator to create a property that returns decrypted field value\"\"\"\n    def decorator(cls):\n        def getter(self):\n            return self.get_decrypted_field(field_name)\n        \n        def setter(self, value):\n            self.set_field_value(field_name, value)\n        \n        # Create property with decrypted suffix\n        prop_name = f\"{field_name}_decrypted\"\n        setattr(cls, prop_name, property(getter, setter))\n        \n        return cls\n    return decorator\n\n\nclass EncryptionTestMixin:\n    \"\"\"Mixin to test encryption functionality\"\"\"\n    \n    @classmethod\n    def test_encryption_roundtrip(cls, test_data: str = \"Test Data 123\") -> bool:\n        \"\"\"Test encryption and decryption roundtrip\"\"\"\n        try:\n            encrypted = encrypt_data(test_data)\n            decrypted = decrypt_data(encrypted)\n            return test_data == decrypted\n        except Exception as e:\n            logger.error(f\"Encryption test failed: {str(e)}\")\n            return False\n    \n    @classmethod\n    def validate_encryption_setup(cls) -> Dict[str, Any]:\n        \"\"\"Validate encryption configuration\"\"\"\n        from .encryption import is_encryption_enabled, _get_encryption_key\n        \n        result = {\n            'encryption_enabled': is_encryption_enabled(),\n            'key_configured': bool(_get_encryption_key()),\n            'roundtrip_test': cls.test_encryption_roundtrip(),\n            'recommendations': []\n        }\n        \n        if not result['encryption_enabled']:\n            result['recommendations'].append(\n                \"Set a secure ENCRYPTION_KEY in your settings\"\n            )\n        \n        if not result['roundtrip_test']:\n            result['recommendations'].append(\n                \"Encryption roundtrip test failed - check your configuration\"\n            )\n        \n        return result\n\n\n# Utility functions for bulk operations\ndef encrypt_model_fields(model_instance, field_names: List[str]) -> None:\n    \"\"\"Encrypt specific fields of a model instance\"\"\"\n    for field_name in field_names:\n        if hasattr(model_instance, field_name):\n            value = getattr(model_instance, field_name)\n            if value:\n                try:\n                    encrypted_value = encrypt_data(value)\n                    setattr(model_instance, field_name, encrypted_value)\n                except EncryptionError as e:\n                    logger.error(f\"Failed to encrypt {field_name}: {str(e)}\")\n\n\ndef decrypt_model_fields(model_instance, field_names: List[str]) -> Dict[str, str]:\n    \"\"\"Decrypt specific fields of a model instance and return as dict\"\"\"\n    result = {}\n    for field_name in field_names:\n        if hasattr(model_instance, field_name):\n            encrypted_value = getattr(model_instance, field_name)\n            if encrypted_value:\n                try:\n                    result[field_name] = decrypt_data(encrypted_value)\n                except DecryptionError as e:\n                    logger.error(f\"Failed to decrypt {field_name}: {str(e)}\")\n                    result[field_name] = encrypted_value  # Fallback to original\n            else:\n                result[field_name] = ''\n    return result\n\n\ndef migrate_to_encrypted_fields(model_class, field_names: List[str], batch_size: int = 100) -> Dict[str, int]:\n    \"\"\"Migrate existing unencrypted data to encrypted format\n    \n    Args:\n        model_class: Django model class\n        field_names: List of field names to encrypt\n        batch_size: Number of records to process in each batch\n        \n    Returns:\n        Dict with statistics (processed, encrypted, failed)\n    \"\"\"\n    stats = {'processed': 0, 'encrypted': 0, 'failed': 0}\n    \n    # Process in batches to avoid memory issues\n    queryset = model_class.objects.all()\n    total = queryset.count()\n    \n    for offset in range(0, total, batch_size):\n        batch = queryset[offset:offset + batch_size]\n        \n        for instance in batch:\n            stats['processed'] += 1\n            \n            try:\n                needs_save = False\n                for field_name in field_names:\n                    if hasattr(instance, field_name):\n                        value = getattr(instance, field_name)\n                        if value and not _is_already_encrypted_data(value):\n                            encrypted_value = encrypt_data(value)\n                            setattr(instance, field_name, encrypted_value)\n                            needs_save = True\n                \n                if needs_save:\n                    instance.save()\n                    stats['encrypted'] += 1\n                    \n            except Exception as e:\n                logger.error(f\"Failed to migrate {instance}: {str(e)}\")\n                stats['failed'] += 1\n    \n    return stats\n\n\ndef _is_already_encrypted_data(value: str) -> bool:\n    \"\"\"Helper function to check if data is already encrypted\"\"\"\n    if not value or len(value) < 50:\n        return False\n    try:\n        import base64\n        base64.b64decode(value.encode('ascii'))\n        return '=' in value\n    except:\n        return False
